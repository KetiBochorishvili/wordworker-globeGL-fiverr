<head>
    <style>
        body {
            margin: 0;
        }

        #legend {
            font-family: 'Source Sans Pro', sans-serif;

            display: flex;

            position: absolute;
            flex-direction: column;
            align-items: flex-start;
            border-radius: 7px;
            z-index: 200;
            left: 40px;
            bottom: 40px;
            max-height: calc(100vh - 80px);
            overflow-y: scroll;
            color: white;
        }

        .gold,
        .purple {
            display: flex;
            flex-direction: row;
            padding: 5px;
        }

        .gold-circle {
            width: 20px;
            height: 20px;
            background-color: #E5B80B;
            border-radius: 50px;
            margin-right: 5px;
        }

        .purple-circle {
            width: 20px;
            height: 20px;
            background-color: white;
            border-radius: 50px;
            margin-right: 5px;
        }

        .gold-text {
            color: #E5B80B !important;
        }
    </style>
    <meta charset="UTF-8">
    <script src="//unpkg.com/globe.gl"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:wght@400;700&display=swap" rel="stylesheet">

</head>

<body>
    <div id="legend">
        <div class="gold">
            <div class="gold-circle"></div>
            <div class="gold-text">Network PoP</div>
        </div>

        <div class="purple">
            <div class="purple-circle"></div>
            <div>Data Center</div>
        </div>
    </div>

    <div id="globeViz"></div>

    <script src="libs/d3.v7.min.js"></script>

    <script>
        // Gen random data

        d3.csv('data/dataset.csv')
            .then(data => {

                let pointsData = {
                    "type": "FeatureCollection",
                    "features": [],
                }
                let filteredData = data.filter((el) => { return el.City !== "Elk Grove Village " && el.City !== "New York" && el.City !== "Secaucus" && el.City !== "Dulles" && el.City !== "Manassas" && el.City !== "Oakland" && el.City !== "Enschede" && el.City !== "Davenport" && el.City !== "Culpeper" && el.City !== "Zwolle" })
                console.log(data, filteredData)

                filteredData.forEach((d, i) => {
                    if (d.Lat.includes('° N'))
                        d.lat = +d.Lat.replace('° N', '');
                    else if (d.Lat.includes('° S'))
                        d.lat = -d.Lat.replace('° S', '');

                    if (d.Long.includes('° E'))
                        d.lng = +d.Long.replace('° E', '');
                    else if (d.Long.includes('° W'))
                        d.lng = - d.Long.replace('° W', '');

                    d.size = 0.15;
                    if (d.Type === 'Data Center') {
                        d.color = 'rgba(255, 255, 255, 0.8)';
                    }
                    else if (d.Type === 'Network PoP') {
                        d.color = 'rgba(229, 184, 11, 0.8)';
                    }
                    pointsData.features.push(
                        {
                            'type': 'Feature',
                            'properties': {
                                'latitude': d.lat,
                                'longitude': d.lng,
                                'city': d.City,
                                'country': d.Country,
                                'region': d.Region,
                                'state': d['State or Prov'],
                                'type': d.Type,
                                'color': d.color
                            },
                            'geometry': {
                                'type': 'Point',
                                'coordinates': [
                                    d.lat,
                                    d.lng
                                ]
                            }
                        }
                    )
                })

                const N = 300;
                const gData = [...Array(N).keys()].map(() => ({
                    lat: (Math.random() - 0.5) * 180,
                    lng: (Math.random() - 0.5) * 360,
                    size: Math.random() / 3,
                    color: ['red', 'white', 'blue', 'green'][Math.round(Math.random() * 3)]
                }));
                console.log(gData, pointsData)

                const world = Globe()
                    .globeImageUrl('//unpkg.com/three-globe/example/img/earth-night.jpg')
                    .backgroundImageUrl('//unpkg.com/three-globe/example/img/night-sky.png')
                    .labelsData(pointsData.features)
                    .labelLat(d => d.properties.latitude)
                    .labelLng(d => d.properties.longitude)
                    .labelText(d => d.properties.city)
                    .labelSize((d) => {
                        if (d.properties.city === "Guadalajara") {
                            return 0.4
                        } else if (d.properties.city === "Kamloops") {
                            return 0.5
                        }
                        // else if (d.properties.city === "San Francisco") {
                        //     return 0.65
                        // } else if (d.properties.city === "San Jose ") {
                        //     return 1.1
                        // }
                        else if (d.properties.city === "Montreal") {
                            return 0.5
                        } else if (d.properties.city === "Geneva" || d.properties.city === "Munich") {
                            return 0.6
                        }
                        else {
                            let pointsWithoutCurrent = pointsData.features.filter((k) => k.properties.city !== d.properties.city);
                            let distanceIsLessThanHalf = pointsWithoutCurrent.some((point) => Math.abs(d.properties.latitude - point.properties.latitude) < 0.5 && Math.abs(d.properties.longitude - point.properties.longitude) < 0.5)
                            if (distanceIsLessThanHalf) {
                                console.log('aris')
                                return 0.1
                            }
                            else {
                                let distanceIsLessThanOne = pointsWithoutCurrent.some((point) => Math.abs(d.properties.latitude - point.properties.latitude) < 1 && Math.abs(d.properties.longitude - point.properties.longitude) < 1)
                                if (distanceIsLessThanOne) {
                                    console.log('aris');

                                    return 0.4
                                }
                                else {
                                    let distanceIsLessThanTwo = pointsWithoutCurrent.some((point) => Math.abs(d.properties.latitude - point.properties.latitude) < 2 && Math.abs(d.properties.longitude - point.properties.longitude) < 2)
                                    if (distanceIsLessThanTwo)
                                        return 0.4;
                                    else {
                                        let distanceIsBetweenTwoAndFour = pointsWithoutCurrent.some((point) => Math.abs(d.properties.latitude - point.properties.latitude) < 4 && Math.abs(d.properties.longitude - point.properties.longitude) < 4)
                                        if (distanceIsBetweenTwoAndFour)
                                            return 0.75
                                        else
                                            return 1
                                    }
                                }
                            }
                        }
                    })
                    .labelDotRadius((d) => {
                        if (d.properties.city === "Guadalajara") {
                            return 0.2
                        } else if (d.properties.city === "Montreal") {
                            return 0.25
                        }
                        else {
                            let pointsWithoutCurrent = pointsData.features.filter((k) => k.properties.city !== d.properties.city);
                            let distanceIsLessThanHalf = pointsWithoutCurrent.some((point) => Math.abs(d.properties.latitude - point.properties.latitude) < 0.5 && Math.abs(d.properties.longitude - point.properties.longitude) < 0.5)
                            if (distanceIsLessThanHalf)
                                return 0.05
                            else {
                                let distanceIsLessThanOne = pointsWithoutCurrent.some((point) => Math.abs(d.properties.latitude - point.properties.latitude) < 1 && Math.abs(d.properties.longitude - point.properties.longitude) < 1)
                                if (distanceIsLessThanOne)
                                    return 0.2
                                else {
                                    let distanceIsLessThanTwo = pointsWithoutCurrent.some((point) => Math.abs(d.properties.latitude - point.properties.latitude) < 2 && Math.abs(d.properties.longitude - point.properties.longitude) < 2)
                                    if (distanceIsLessThanTwo)
                                        return 0.25;
                                    else {
                                        let distanceIsBetweenTwoAndFour = pointsWithoutCurrent.some((point) => Math.abs(d.properties.latitude - point.properties.latitude) < 4 && Math.abs(d.properties.longitude - point.properties.longitude) < 4)
                                        if (distanceIsBetweenTwoAndFour)
                                            return 0.4
                                        else
                                            return 0.8
                                    }
                                }
                            }
                        }
                    })
                    .labelColor((d) => d.properties.color)
                    .labelResolution(2)
                    // .onGlobeClick(() => world.controls().autoRotate = false)
                    (document.getElementById('globeViz'))

                // world.controls().autoRotate = true;
                // world.controls().autoRotateSpeed = 0.4;

                // function stopAutoRotate() {
                //     world.controls().autoRotate = false
                // }

                // const globeElement = document.getElementById('globeViz');
                // globeElement.addEventListener('mousedown', stopAutoRotate);
                // globeElement.addEventListener('touchstart', stopAutoRotate);
            })

    </script>
</body>