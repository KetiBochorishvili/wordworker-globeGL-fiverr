<head>
    <style>
        body {
            margin: 0;
        }
    </style>
    <meta charset="UTF-8">
    <script src="//unpkg.com/globe.gl"></script>
</head>

<body>
    <div id="globeViz"></div>
    <script src="libs/d3.v7.min.js"></script>

    <script>
        // Gen random data

        d3.csv('data/dataset.csv')
            .then(data => {
                console.log(data)

                let pointsData = {
                    "type": "FeatureCollection",
                    "features": [],
                }
                data.forEach((d, i) => {
                    if (d.Lat.includes('° N'))
                        d.lat = +d.Lat.replace('° N', '');
                    else if (d.Lat.includes('° S'))
                        d.lat = -d.Lat.replace('° S', '');

                    if (d.Long.includes('° E'))
                        d.lng = +d.Long.replace('° E', '');
                    else if (d.Long.includes('° W'))
                        d.lng = - d.Long.replace('° W', '');

                    d.size = 0.15;
                    if (d.Type === 'Data Center')
                        d.color = '#A020F0'
                    else if (d.Type === 'Network PoP')
                        d.color = '#E5B80B'

                    pointsData.features.push(
                        {
                            'type': 'Feature',
                            'properties': {
                                'latitude': d.lat,
                                'longitude': d.lng,
                                'city': d.City,
                                'country': d.Country,
                                'region': d.Region,
                                'state': d['State or Prov'],
                                'type': d.Type,
                                'color': d.color
                            },
                            'geometry': {
                                'type': 'Point',
                                'coordinates': [
                                    d.lat,
                                    d.lng
                                ]
                            }
                        }
                    )
                })

                const N = 300;
                const gData = [...Array(N).keys()].map(() => ({
                    lat: (Math.random() - 0.5) * 180,
                    lng: (Math.random() - 0.5) * 360,
                    size: Math.random() / 3,
                    color: ['red', 'white', 'blue', 'green'][Math.round(Math.random() * 3)]
                }));
                console.log(gData, pointsData)
                const world = Globe()
                    .globeImageUrl('//unpkg.com/three-globe/example/img/earth-night.jpg')
                    .backgroundImageUrl('//unpkg.com/three-globe/example/img/night-sky.png')
                    .labelsData(pointsData.features)
                    .labelLat(d => d.properties.latitude)
                    .labelLng(d => d.properties.longitude)
                    .labelText(d => d.properties.city)
                    .labelSize((d) => {
                        // let pointsWithoutCurrent = pointsData.features.filter((k) => k.properties.city !== d.properties.city);
                        // let distanceIsLessThanHalf = pointsWithoutCurrent.some((point) => Math.abs(d.properties.latitude - point.properties.latitude) < 0.5 && Math.abs(d.properties.longitude - point.properties.longitude) < 0.5)
                        // if (distanceIsLessThanHalf)
                        //     return 0.1
                        // else {
                        //     let distanceIsLessThanOne = pointsWithoutCurrent.some((point) => Math.abs(d.properties.latitude - point.properties.latitude) < 1 && Math.abs(d.properties.longitude - point.properties.longitude) < 1)
                        //     if (distanceIsLessThanOne)
                        //         return 0.25
                        //     else {
                        //         let distanceIsLessThanTwo = pointsWithoutCurrent.some((point) => Math.abs(d.properties.latitude - point.properties.latitude) < 2 && Math.abs(d.properties.longitude - point.properties.longitude) < 2)
                        //         if (distanceIsLessThanTwo)
                        //             return 0.5;
                        //         else {
                        //             let distanceIsBetweenTwoAndFour = pointsWithoutCurrent.some((point) => Math.abs(d.properties.latitude - point.properties.latitude) < 4 && Math.abs(d.properties.longitude - point.properties.longitude) < 4)
                        //             if (distanceIsBetweenTwoAndFour)
                        //                 return 0.75
                        //             else
                        //                 return 1
                        //         }
                        //     }
                        // }

                        let pointsWithoutCurrent = pointsData.features.filter((k) => k.properties.city !== d.properties.city);
                        let distanceIsLessThanHalf = pointsWithoutCurrent.some((point) => Math.abs(d.properties.latitude - point.properties.latitude) < 0.5 && Math.abs(d.properties.longitude - point.properties.longitude) < 0.5)
                        if (distanceIsLessThanHalf)
                            return 0.05
                        else {
                            let distanceIsLessThanOne = pointsWithoutCurrent.some((point) => Math.abs(d.properties.latitude - point.properties.latitude) < 1 && Math.abs(d.properties.longitude - point.properties.longitude) < 1)
                            if (distanceIsLessThanOne)
                                return 0.15
                            else {
                                let distanceIsLessThanTwo = pointsWithoutCurrent.some((point) => Math.abs(d.properties.latitude - point.properties.latitude) < 2 && Math.abs(d.properties.longitude - point.properties.longitude) < 2)
                                if (distanceIsLessThanTwo)
                                    return 0.3;
                                else {
                                    let distanceIsBetweenTwoAndFour = pointsWithoutCurrent.some((point) => Math.abs(d.properties.latitude - point.properties.latitude) < 4 && Math.abs(d.properties.longitude - point.properties.longitude) < 4)
                                    if (distanceIsBetweenTwoAndFour)
                                        return 0.6
                                    else
                                        return 0.8
                                }
                            }
                        }
                    })
                    .labelDotRadius((d) => {
                        // let pointsWithoutCurrent = pointsData.features.filter((k) => k.properties.city !== d.properties.city);
                        // let distanceIsLessThanHalf = pointsWithoutCurrent.some((point) => Math.abs(d.properties.latitude - point.properties.latitude) < 0.5 && Math.abs(d.properties.longitude - point.properties.longitude) < 0.5)
                        // if (distanceIsLessThanHalf)
                        //     return 0.05
                        // else {
                        //     let distanceIsLessThanOne = pointsWithoutCurrent.some((point) => Math.abs(d.properties.latitude - point.properties.latitude) < 1 && Math.abs(d.properties.longitude - point.properties.longitude) < 1)
                        //     if (distanceIsLessThanOne)
                        //         return 0.1
                        //     else {
                        //         let distanceIsLessThanTwo = pointsWithoutCurrent.some((point) => Math.abs(d.properties.latitude - point.properties.latitude) < 2 && Math.abs(d.properties.longitude - point.properties.longitude) < 2)
                        //         if (distanceIsLessThanTwo)
                        //             return 0.2;
                        //         else {
                        //             let distanceIsBetweenTwoAndFour = pointsWithoutCurrent.some((point) => Math.abs(d.properties.latitude - point.properties.latitude) < 4 && Math.abs(d.properties.longitude - point.properties.longitude) < 4)
                        //             if (distanceIsBetweenTwoAndFour)
                        //                 return 0.4
                        //             else
                        //                 return 0.8
                        //         }
                        //     }
                        // }

                        let pointsWithoutCurrent = pointsData.features.filter((k) => k.properties.city !== d.properties.city);
                        let distanceIsLessThanHalf = pointsWithoutCurrent.some((point) => Math.abs(d.properties.latitude - point.properties.latitude) < 0.5 && Math.abs(d.properties.longitude - point.properties.longitude) < 0.5)
                        if (distanceIsLessThanHalf)
                            return 0.025
                        else {
                            let distanceIsLessThanOne = pointsWithoutCurrent.some((point) => Math.abs(d.properties.latitude - point.properties.latitude) < 1 && Math.abs(d.properties.longitude - point.properties.longitude) < 1)
                            if (distanceIsLessThanOne)
                                return 0.05
                            else {
                                let distanceIsLessThanTwo = pointsWithoutCurrent.some((point) => Math.abs(d.properties.latitude - point.properties.latitude) < 2 && Math.abs(d.properties.longitude - point.properties.longitude) < 2)
                                if (distanceIsLessThanTwo)
                                    return 0.1;
                                else {
                                    let distanceIsBetweenTwoAndFour = pointsWithoutCurrent.some((point) => Math.abs(d.properties.latitude - point.properties.latitude) < 4 && Math.abs(d.properties.longitude - point.properties.longitude) < 4)
                                    if (distanceIsBetweenTwoAndFour)
                                        return 0.2
                                    else
                                        return 0.5
                                }
                            }
                        }
                    })
                    .labelColor((d) => d.properties.color)
                    .labelResolution(2)
                    // .pointsData(data)
                    // .pointAltitude('size')
                    // .pointColor('color')
                    .onGlobeClick(() => world.controls().autoRotate = false)
                    // .onZoom(() => world.controls().autoRotate = false)
                    (document.getElementById('globeViz'))

                world.controls().autoRotate = true;
                world.controls().autoRotateSpeed = 0.6;
            })

    </script>
</body>